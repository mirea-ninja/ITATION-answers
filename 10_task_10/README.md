# Задание 10. Финал

## Задание

> Вот и настало заключительно испытание. Сегодня нам было передано послание из будущего, к сожалению, нынешние панды-мастера не в силах разгадать его. Мы думаем, что новые ученики смогут решить данную проблему. Я уверен, ты с этим легко справишься. Желаю удачи!

<details>
    <summary>Входные данные</summary>
    Answer: 7235950 8653973 22582420 46400007 30942811 18377826 9090748 1809330 24157907 26947293 26463809 19620468 27720117 24249324 18761476\n\nprivate Key: https://gist.github.com/Dragonprod/a3b2c7bfc75d442048b9c1e148751271\n\nsolver.py: https://gist.github.com/Dragonprod/4f0b5bac11d52efeb706b8465f41aa96

## Решение

Нам дан ответ, скрипт для решения и секретный ключ. После запуска на трёх символах скрипт зависает и не подаёт никаких признаков жизни, кроме потребления 100% мощностей одного ядра. Прервав скрипт, видим, что выполнение скрипта падает на строке
`x = (a ** b) ** (c ** d)`

На Python `**` означает возведение в степень. Давайте посмотрим, что же возводится, и в какую степень. Видим, что дешифрование производится блоками по три символа. _a_ — как раз очередной элемент из потока зашифрованных данных.

Остальные переменные берутся из `powerful.key` — это файл с данными, закодированными в base64, внутри которого лежит JSON. В `private_key` лежат пары `(c, d)`, а в `common_key` — пары `(b, n)`. Число _n_ используется чуть позже: для получения символов используется не само число _x_, а его остаток от деления на _n_.

Первое число вычисляется быстро: в ключе `b = c = d = 1`, и мы получаем первые три символа флага: `ugr`. Все же остальные числа имеют длину 20–30 бит (7–9 десятичных знаков), и даже одно возведение в степень уже вряд ли вычислится на среднем современном процессоре.

Дальше будут использованы несколько математических терминов. Под _вычислением по модулю n_ мы будем понимать вычисление остатка от деления на _n_. Два числа называются _сравнимыми_ или _равными по модулю n_, если их остатки от деления на _n_ равны. Разумеется, везде, где не сказано иное, подразумеваются целые неотрицательные числа. _Взаимно простыми_ числами называются два таких числа, у которых нет общего делителя, кроме единицы.

Давайте придумаем, как соптимизировать вычисление. Во-первых, довольно логично, что раз мы результат берём по модулю, можно брать по модулю результат на каждой итерации. В Python это проще всего записать так: `pow(a ** b, c ** d, n)`. Функция `pow` в Python с тремя аргументами эффективно вычисляет степень числа по нужному модулю.

Эта оптимизация уже сильно упрощает процесс, но этого мало. Рассмотрим выражение _a_<sup>_b_</sup> mod _n_, где _a_ > _n_. _a_ представимо в виде _a_ = _kn_ + _x_, где _x_ = _a_ mod _n_. Тогда (_kn_ + _x_)<sup>_b_</sup> = _kn_<sup>_b_</sup> + _b_(_kn_)<sup>_b_ − 1</sup>_x_ + … + _x_<sup>_b_</sup>. И, поскольку все элементы, кроме последнего, делятся на _n_, то выражение сравнимо с _x_<sup>_b_</sup> по модулю _n_.

Таким образом, от выражения _a_<sup>_b_</sup> нас интересует только остаток от деления на _n_, и наше выражение превращается в `pow(pow(a, b, n), c ** d, n)`. Соптимизировать _c_<sup>_d_</sup> таким же образом не выйдет — к сожалению, мы получим другой результат.

Назовём наше число `pow(a, b, n)` буквой _q_. Мы хотим посчитать остаток от деления _e_ в некоторой степени на _n_. Рассмотрим последовательность: _q_ mod _n_, _q_<sup>2</sup> mod _n_, _q_<sup>3</sup> mod _n_ …. Все эти числа лежат в диапазоне от 1 до _n_ − 1.

> Здесь мы используем тот факт, что _q_ и _n_ взаимно просты. Это было верно для наших сообщений (и в целом, подобные условия нередко являются обязательными для различных криптографических систем), но в общем случае такие вещи стоит проверять, чтобы не ошибиться.

Очевидно, что рано или поздно остатки начнут повторяться — хотя бы на _n_-той операции. При этом если мы какой-то повторяющийся остаток снова умножим на _q_, то получим то же самое число — таким образом, последовательность зацикливается. Если мы найдём длину этого цикла, возводить в нужную степень и не придётся — все итерации цикла можно просто пропустить, вычислив вместо нужной степени остаток от её деления на длину цикла.

Поскольку наш модуль был небольшим, можно было просто перебрать все степени _q_, пока мы не встретим этот самый цикл. Но, на самом деле, за нас уже всё сделал Леонард Эйлер — его [теорема](<https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D0%B5%D0%BC%D0%B0_%D0%AD%D0%B9%D0%BB%D0%B5%D1%80%D0%B0_(%D1%82%D0%B5%D0%BE%D1%80%D0%B8%D1%8F_%D1%87%D0%B8%D1%81%D0%B5%D0%BB)>) гласит о том, что длина такого цикла для взаимнопростых _q_ и _n_ равна функции Эйлера числа _n_. Функция Эйлера _φ_(_n_) — это количество натуральных чисел, меньших _n_ и взаимно простых с ним.

Опять же, её можно посчитать и наивно, но с помощью несложных математических преобразований можно вычислить функцию Эйлера, зная делители _n_.

Таким образом, итоговая формула приобретает такой вид:

```python
pow(pow(a, b, n), pow(c, d, phi(n)), n)
```

Используя её, мы мгновенно получаем ответ - [solution.py](solution.py)

## Ответ

`ninja{s0ck3t_i0_ef1a4dfc}`
